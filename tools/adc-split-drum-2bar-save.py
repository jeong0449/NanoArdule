#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
split_drums_2bar_save.py (simple 2-bar slicer, no GROOVE/grouping)

Overview
- Extract only CH10 (drum) events from a Type 0/1 MIDI file and slice them into 2-bar patterns.
- Save each slice using the <GEN>_Pnnn.MID naming scheme (8.3-safe).
- Infer the genre code from the filename using GENRE_MAP, or force it with the --genre option.
- --no-overwrite: continue numbering from the next available index after existing <GEN>_Pnnn.MID files.
- --export-grid: visualize each slice as an ADT/ADP-style 2-bar drum grid PNG.
- --grid-pdf: collect PNGs generated by --export-grid into a large (high-resolution) PDF, and
  if Ghostscript is available on PATH, resize pages to A4 (595x842 pt),
  saving the final file as "<original MIDI name>_grids_A4_2col.pdf".
  After a successful PDF is produced, the source PNG files are removed.
- --print-genre-only: do not slice the MIDI file; infer and print only the genre code from the filename, then exit.

Tail handling rule
- If the total length is bar_ticks * N + tail_ticks,
  and tail_ticks >= bar_ticks * 0.5, generate one additional final 2-bar pattern
  from the last bar.
"""

import argparse
import re
import csv
import io
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, List, Optional, Set, Tuple

import mido

import subprocess
import shutil
import math

# Pillow is optional (required for --export-grid / --grid-pdf)
try:
    from PIL import Image, ImageDraw, ImageFont  # type: ignore
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False


# ---------------------------------------------------------------------------
#  Ghostscript helper (optional A4 resize for grid PDF)
# ---------------------------------------------------------------------------

def find_ghostscript_executable() -> Optional[str]:
    """
    Find a Ghostscript executable on PATH.
    Windows: gswin64c / gswin32c
    Unix-like: gs
    """
    candidates = ["gswin64c", "gswin32c", "gs"]
    for name in candidates:
        path = shutil.which(name)
        if path:
            return path
    return None


def convert_pdf_to_a4_with_ghostscript(gs_exe: str, input_pdf: Path, output_pdf: Path) -> bool:
    """
    Resize PDF pages to A4 (595x842 pt) using Ghostscript.
    - Does not resample embedded bitmap images; adjusts page box and content scaling only.
    """
    cmd = [
        gs_exe,
        "-sDEVICE=pdfwrite",
        "-o", str(output_pdf),
        "-dDEVICEWIDTHPOINTS=595",
        "-dDEVICEHEIGHTPOINTS=842",
        "-dFIXEDMEDIA",
        "-dPDFFitPage",
        "-dNOPAUSE",
        "-dBATCH",
        str(input_pdf),
    ]

    print("[grid-pdf] Running Ghostscript for A4 resize:")
    print("          " + " ".join(cmd))

    try:
        result = subprocess.run(cmd, check=False)
    except FileNotFoundError:
        print("[grid-pdf] ERROR: Ghostscript executable disappeared while running.")
        return False

    if result.returncode != 0:
        print(f"[grid-pdf] Ghostscript failed with exit code {result.returncode}.")
        return False

    if not output_pdf.exists():
        print("[grid-pdf] Ghostscript reported success but output file not found.")
        return False

    return True


# ---------------------------------------------------------------------------
#  Genre inference
# ---------------------------------------------------------------------------

GENRE_MAP = [
    # Rock / Bossa / Funk / Jazz / Blues / Pop / Ballad
    (re.compile(r'rock', re.I), 'RCK'),
    (re.compile(r'bossa|bossanova|bosa', re.I), 'BNV'),
    (re.compile(r'funk', re.I), 'FNK'),
    (re.compile(r'jazz', re.I), 'JZZ'),
    (re.compile(r'blues?', re.I), 'BLU'),
    (re.compile(r'pop', re.I), 'POP'),
    (re.compile(r'ballad|bal', re.I), 'BAL'),

    # Latin + Afro-Cuban + Cha-cha
    (re.compile(r'latin', re.I), 'LAT'),
    (re.compile(r'afrocub|afrocuba[n]?|afro[\s\-_]*cuba[n]?', re.I), 'AFC'),
    (re.compile(r'chacha|cha[\s\-_]*cha', re.I), 'LAT'),

    # Samba / Waltz / Swing / Shuffle / Reggae / Metal
    (re.compile(r'samba', re.I), 'SMB'),
    (re.compile(r'waltz|wlz', re.I), 'WLZ'),
    (re.compile(r'swing|swg', re.I), 'SWG'),
    (re.compile(r'shuffle|shf', re.I), 'SHF'),
    (re.compile(r'reggae', re.I), 'REG'),
    (re.compile(r'metal', re.I), 'MTL'),

    # Hip-hop
    (re.compile(r'hip\s*-?\s*hop|hiphop|hhp', re.I), 'HHP'),

    # Rhythm & Blues (R&B)
    (re.compile(r'r\s*&\s*b|randb|rnb', re.I), 'RNB'),

    # EDM family: dance / dnc / edm
    (re.compile(r'edm|dance|dnc', re.I), 'EDM'),

    # House & Techno
    (re.compile(r'house|hse', re.I), 'HSE'),
    (re.compile(r'techno|tno', re.I), 'TNO'),
]


def strip_leading_digits(name_noext: str) -> str:
    """Remove leading digits and separators from a filename stem."""
    return re.sub(r'^[0-9]+[- _\.]*', '', name_noext)


def infer_genre_code_from_name(filename: str) -> str:
    """Infer 3-letter genre code from filename using GENRE_MAP."""
    stem = Path(filename).stem
    stem = strip_leading_digits(stem)
    for pat, code in GENRE_MAP:
        if pat.search(stem):
            return code
    return 'DRM'  # default / fallback


def sanitize_83(s: str) -> str:
    """Make a string DOS 8.3-safe: alnum + underscore, uppercased."""
    s = re.sub(r'[^A-Za-z0-9_]', '', s).upper()
    return s[:8]




# ---------------------------------------------------------------------------
#  Optional output naming override (--names)
# ---------------------------------------------------------------------------

def load_names_file_csv(path: Path) -> dict[int, str]:
    """Load a CSV naming override file.

    Required columns (recommended header):
      - index : integer pattern index (the NNN in *_PNNN.MID)
      - name  : desired base filename (will be sanitized to DOS 8.3 and uppercased)

    Notes
    - The CSV MAY include a header row. If the header is missing, the first two
      columns are interpreted as (index, name).
    - Additional columns MAY be present and will be ignored.
    - Blank lines are ignored.
    - Lines starting with '#' are ignored (after leading whitespace).

    Example:
        index,name
        1,AFC_A
        2,AFC_B
        12,AFC_BRK1
    """
    try:
        raw = path.read_text(encoding="utf-8")
    except OSError as e:
        raise SystemExit(f"Failed to read --names file: {path} ({e})")

    # Support comment-only lines (CSV itself doesn't define comments)
    cleaned_lines: list[str] = []
    for ln in raw.splitlines():
        s = ln.lstrip()
        if not s:
            continue
        if s.startswith("#"):
            continue
        cleaned_lines.append(ln)
    cleaned = "\n".join(cleaned_lines)

    names_map: dict[int, str] = {}

    # Try header-based CSV first
    f = io.StringIO(cleaned)
    reader = csv.DictReader(f)
    if reader.fieldnames:
        field_lut = {h.strip().lower(): h for h in reader.fieldnames if h}
        if "index" in field_lut and "name" in field_lut:
            idx_key = field_lut["index"]
            name_key = field_lut["name"]
            for row in reader:
                if not row:
                    continue
                idx_raw = (row.get(idx_key) or "").strip()
                name_raw = (row.get(name_key) or "").strip()
                if not idx_raw or not name_raw:
                    continue
                try:
                    idx = int(idx_raw)
                except ValueError:
                    raise SystemExit(f"Invalid index in --names CSV: {idx_raw!r} (file: {path})")
                names_map[idx] = name_raw
            return names_map

    # Fallback: no header -> first two columns are (index, name)
    f2 = io.StringIO(cleaned)
    reader2 = csv.reader(f2)
    for row in reader2:
        if not row or len(row) < 2:
            continue
        idx_raw = str(row[0]).strip()
        name_raw = str(row[1]).strip()
        if not idx_raw or not name_raw:
            continue
        try:
            idx = int(idx_raw)
        except ValueError:
            raise SystemExit(f"Invalid index in --names CSV: {idx_raw!r} (file: {path})")
        names_map[idx] = name_raw

    return names_map


def choose_basename_csv(default_basename: str, pat_idx: int, names_map: dict[int, str]) -> str:
    """Choose output basename using optional CSV overrides."""
    if pat_idx in names_map:
        return sanitize_83(names_map[pat_idx])
    return sanitize_83(default_basename)


# ---------------------------------------------------------------------------
#  MIDI helpers
# ---------------------------------------------------------------------------

def current_time_signature(track: mido.MidiTrack, abs_tick: int, ticks_per_beat: int) -> Tuple[int, int]:
    """Return (numerator, denominator) at given absolute tick."""
    num, den = 4, 4
    t = 0
    for msg in track:
        t += msg.time
        if t > abs_tick:
            break
        if msg.type == 'time_signature':
            num = msg.numerator
            den = msg.denominator
    return num, den


def current_tempo(track: mido.MidiTrack, abs_tick: int) -> int:
    """Return tempo (microseconds per beat) at given absolute tick."""
    tempo = 500000  # default 120 BPM
    t = 0
    for msg in track:
        t += msg.time
        if t > abs_tick:
            break
        if msg.type == 'set_tempo':
            tempo = msg.tempo
    return tempo


def ticks_per_bar(tpb: int, num: int, den: int) -> int:
    """Calculate ticks per bar for given time signature."""
    return int(round(tpb * num * (4.0 / den)))


def build_absolute_track(track: mido.MidiTrack) -> List[mido.Message]:
    """Convert delta-time track into absolute-time messages."""
    out: List[mido.Message] = []
    t = 0
    for msg in track:
        t += msg.time
        out.append(msg.copy(time=t))
    return out


# ---------------------------------------------------------------------------
#  Event helpers
# ---------------------------------------------------------------------------

def build_events_by_tick(
    abs_msgs: List[mido.Message],
    start: int,
    end: int,
    channel: int = 9,
) -> Dict[int, Set[int]]:
    """Collect note_on events into a dict: tick -> set(note)."""
    events: Dict[int, Set[int]] = {}
    for m in abs_msgs:
        if start <= m.time < end:
            if m.type == 'note_on' and getattr(m, 'channel', None) == channel and m.velocity > 0:
                rel = m.time - start
                s = events.setdefault(rel, set())
                s.add(m.note)
    return events

def detect_steps_per_bar_for_pattern(
    events_by_tick: Dict[int, Set[int]],
    bar_ticks: int,
) -> Tuple[int, str]:
    """
    Estimate which grid candidate best matches the note tick positions.
    - straight (16 steps/bar)
    - 8th triplet (12 steps/bar)
    - 16th triplet (24 steps/bar)
    bar_ticks: ticks per bar for the current time signature.
    """
    if not events_by_tick or bar_ticks <= 0:
        return 16, "straight"

    candidates = [16, 12, 24]
    best_steps = 16
    best_score = math.inf

    tick_positions = sorted(events_by_tick.keys())
    n = len(tick_positions)
    if n == 0:
        return 16, "straight"

    for steps_per_bar in candidates:
        step_ticks = bar_ticks / float(steps_per_bar)
        if step_ticks <= 0:
            continue

        score = 0.0
        for t in tick_positions:
            # bar 단위로 나누어 생각
            t_mod = t % bar_ticks
            # 가장 가까운 grid 라인까지 거리
            grid_idx = round(t_mod / step_ticks)
            nearest = grid_idx * step_ticks
            d = t_mod - nearest
            score += d * d

        score /= n
        if score < best_score:
            best_score = score
            best_steps = steps_per_bar

    if best_steps == 16:
        label = "straight"
    elif best_steps == 12:
        label = "triplet-8T"
    else:
        label = "triplet-16T"

    return best_steps, label




# ---------------------------------------------------------------------------
#  Drum slots & mapping (for grid)
# ---------------------------------------------------------------------------

SLOT_LABELS = [
    "BD",   # 0
    "SD",   # 1
    "RS",   # 2
    "CP",   # 3
    "CH",   # 4
    "PH",   # 5
    "OH",   # 6
    "LT",   # 7
    "HT",   # 8
    "CR",   # 9
    "RD",   #10
    "PER",  #11
]
N_SLOTS = len(SLOT_LABELS)


def note_to_slot(note: int) -> Optional[int]:
    """
    Map any GM drum note (35–81) into
    Ardule 12-category slot index.
    """
    # 0: BD (Kick)
    if note in (35, 36):
        return 0

    # 1: SD (Snare)
    if note in (38, 40):
        return 1

    # 2: RS (Side Stick)
    if note == 37:
        return 2

    # 3: CP (Hand Clap)
    if note == 39:
        return 3

    # 4: CH (Closed Hi-Hat)
    if note == 42:
        return 4

    # 5: PH (Pedal Hi-Hat)
    if note == 44:
        return 5

    # 6: OH (Open Hi-Hat)
    if note == 46:
        return 6

    # 7: LT (Low/Low-mid toms)
    if note in (41, 45, 47):
        return 7

    # 8: HT (Mid/High toms)
    if note in (43, 48, 50):
        return 8

    # 9: CR (Crash-like cymbals)
    if note in (49, 52, 55, 57):
        return 9

    # 10: RD (Ride cymbals and bell)
    if note in (51, 53, 59):
        return 10

    # 11: PER (Percussion bucket: Cowbell + Latin / FX)
    if note == 56 or (60 <= note <= 81):
        return 11

    return None


# ---------------------------------------------------------------------------
#  Grid export (PNG, smart rows)
# ---------------------------------------------------------------------------

@dataclass
class PatternForGrid:
    length: int
    events_by_tick: Dict[int, Set[int]]


def export_pattern_grid_png(
    pattern: PatternForGrid,
    title: str,
    out_path: Path,
    cols: int = 32,
) -> None:
    """
    Export ADP/ADT-style 2-bar drum grid PNG.

    X-axis:  cols columns (default 32 = 16 steps/bar)
    Y-axis:  12 rows:
       - top:  OTHER note rows (each note number is a label)
       - bottom: drum slots (slot index 0..11, labels in SLOT_LABELS,
                 BD at the very bottom).
    """
    if not PIL_AVAILABLE:
        print(f"[WARN] Pillow not available; cannot export grid for {out_path.name}")
        return

    L = pattern.length
    if L <= 0:
        return

    # 1) analyze used slots / other notes
    used_slots: Set[int] = set()
    other_notes_set: Set[int] = set()

    for notes in pattern.events_by_tick.values():
        for nt in notes:
            sl = note_to_slot(nt)
            if sl is None or sl < 0 or sl >= N_SLOTS:
                other_notes_set.add(nt)
            else:
                used_slots.add(sl)

    used_slots_sorted = sorted(used_slots)
    other_notes_sorted = sorted(other_notes_set)

    # 2) row allocation
    free_rows = max(0, N_SLOTS - len(used_slots_sorted))
    n_others_to_show = min(len(other_notes_sorted), free_rows)
    shown_others = other_notes_sorted[:n_others_to_show]

    slot_row_quota = N_SLOTS - n_others_to_show

    unused_slots_sorted = sorted(set(range(N_SLOTS)) - set(used_slots_sorted))
    extra_slots_needed = max(0, slot_row_quota - len(used_slots_sorted))
    extra_slots = unused_slots_sorted[:extra_slots_needed]

    slot_rows_all = used_slots_sorted + extra_slots
    slot_rows_for_display = sorted(slot_rows_all, reverse=True)  # BD at bottom

    row_types: List[Tuple[str, int]] = []
    row_labels: List[str] = []

    for note in shown_others:
        row_types.append(('other', note))
        row_labels.append(str(note))

    for sl in slot_rows_for_display:
        row_types.append(('slot', sl))
        if 0 <= sl < len(SLOT_LABELS):
            row_labels.append(SLOT_LABELS[sl])
        else:
            row_labels.append(f"S{sl}")

    rows = len(row_types)
    if rows == 0:
        rows = 1
        row_types = []
        row_labels = ["(empty)"]

    # 3) image geometry
    cell_w = 10
    cell_h = 10
    left_margin = 40
    top_margin = 30
    right_margin = 10
    bottom_margin = 10

    width = left_margin + cols * cell_w + right_margin
    height = top_margin + rows * cell_h + bottom_margin

    img = Image.new("RGB", (width, height), (255, 255, 255))
    draw = ImageDraw.Draw(img)

    try:
        font_title = ImageFont.truetype("arial.ttf", 16)
    except Exception:
        font_title = ImageFont.load_default()
    try:
        font_label = ImageFont.load_default()
    except Exception:
        font_label = font_title

    # 4) title centered
    if hasattr(draw, "textbbox"):
        bbox = draw.textbbox((0, 0), title, font=font_title)
        text_w = bbox[2] - bbox[0]
        text_h = bbox[3] - bbox[1]
    else:
        text_w, text_h = draw.textsize(title, font=font_title)

    title_x = (width - text_w) // 2
    title_y = 5
    draw.text((title_x, title_y), title, fill=(0, 0, 0), font=font_title)

    gx = left_margin
    gy = top_margin

    # 5) vertical grid lines (bar / beat)
    cols_per_bar = cols // 2
    beat_step = cols_per_bar // 4 if cols_per_bar >= 4 else 1

    for c in range(cols + 1):
        x = gx + c * cell_w
        is_bar_boundary = (c == cols_per_bar)
        is_beat_boundary = (c % beat_step == 0)
        if is_bar_boundary:
            color = (0, 0, 0)
            width_line = 3
        elif is_beat_boundary:
            color = (80, 80, 80)
            width_line = 1
        else:
            color = (220, 220, 220)
            width_line = 1
        draw.line((x, gy, x, gy + rows * cell_h), fill=color, width=width_line)

    # horizontal grid lines
    for r in range(rows + 1):
        y = gy + r * cell_h
        draw.line((gx, y, gx + cols * cell_w, y), fill=(220, 220, 220))

    # 6) row headers
    for idx, label in enumerate(row_labels):
        y = gy + idx * cell_h + 2
        draw.text((5, y), label, fill=(0, 0, 0), font=font_label)

    # 7) row index maps
    row_index_for_slot: Dict[int, int] = {}
    row_index_for_other: Dict[int, int] = {}
    for idx, (kind, val) in enumerate(row_types):
        if kind == 'slot':
            row_index_for_slot[val] = idx
        else:
            row_index_for_other[val] = idx

    # 8) events
    ticks_per_col = L / cols if cols > 0 else 1.0
    for t, notes in pattern.events_by_tick.items():
        col = int(round(t / ticks_per_col)) if ticks_per_col > 0 else 0
        if col < 0:
            col = 0
        if col >= cols:
            col = cols - 1
        for nt in notes:
            sl = note_to_slot(nt)
            if sl is not None and sl in row_index_for_slot:
                row = row_index_for_slot[sl]
            elif nt in row_index_for_other:
                row = row_index_for_other[nt]
            else:
                continue
            x0 = gx + col * cell_w + 1
            y0 = gy + row * cell_h + 1
            x1 = x0 + cell_w - 2
            y1 = y0 + cell_h - 2
            draw.rectangle((x0, y0, x1, y1), fill=(0, 0, 0))

    img.save(out_path)
    print(f"Grid PNG saved: {out_path.name}")


def export_grid_pdf_two_column(png_paths: List[Path], out_path: Path, original_filename: str) -> None:
    """
    Collect grid PNGs into a high-resolution PDF.

    NOTE: Layout is forced to a fixed 2x5 grid per page (10 images/page) to avoid
    cropping/overlap when PNG aspect ratios differ.

    Design goal:
    - Make the PDF page title clearly larger than the per-grid (PNG-embedded) titles.
    - Do NOT touch PNG generation logic; instead:
        * Increase PDF title font size
        * Add a small padding by scaling PNGs slightly smaller inside each slot
    """
    if not PIL_AVAILABLE:
        print(f"[WARN] Pillow not available; cannot export PDF {out_path.name}")
        return
    if not png_paths:
        print("[WARN] No grid PNGs to include in PDF.")
        return

    # Large canvas approximating A4 at ~300 DPI (portrait)
    A4_W, A4_H = 2480, 3508
    PDF_RESOLUTION = 300  # px/in -> maps A4 pixels to ~595x842 pt in PDF viewers

    # Page layout (2x5)
    cols, rows = 2, 5
    margin_side = 120

    # Title area: increased to accommodate a larger font
    title_y = 140  # slightly larger top margin
    title_font_size = 64  # was 40; larger page title
    title_gap_below = 20  # gap from title baseline area to the first row of images

    margin_top = title_y + title_font_size + title_gap_below
    margin_bottom = 120
    inner_margin = 24    # gap between slots (narrower grid spacing)

    # Slightly shrink images inside slots so the PNG-embedded titles feel smaller
    # relative to the page title (without modifying PNG generation).
    image_scale = 0.92   # 0.88~0.95 are reasonable

    # Title font: try Windows Arial Bold first, then DejaVuSans, then fallback.
    font_title = None
    for cand in [
        r"C:\Windows\Fonts\arialbd.ttf",
        r"C:\Windows\Fonts\arial.ttf",
        "DejaVuSans-Bold.ttf",
        "DejaVuSans.ttf",
    ]:
        try:
            font_title = ImageFont.truetype(cand, title_font_size)
            break
        except Exception:
            pass
    if font_title is None:
        font_title = ImageFont.load_default()

    title_text = f"Original MIDI: {original_filename}"

    usable_w = A4_W - 2 * margin_side - (cols - 1) * inner_margin
    usable_h = A4_H - margin_top - margin_bottom - (rows - 1) * inner_margin
    slot_w = usable_w // cols
    slot_h = usable_h // rows

    pages: List[Image.Image] = []

    def _new_page() -> Image.Image:
        page = Image.new("RGB", (A4_W, A4_H), "white")
        draw = ImageDraw.Draw(page)

        # Centered title near the top
        try:
            bbox = draw.textbbox((0, 0), title_text, font=font_title)
            title_w = bbox[2] - bbox[0]
        except Exception:
            title_w, _ = draw.textsize(title_text, font=font_title)

        draw.text(((A4_W - title_w) // 2, title_y), title_text, fill=(0, 0, 0), font=font_title)
        return page

    page = _new_page()

    per_page = cols * rows
    placed = 0  # count successfully placed images (so failures don't leave blank slots)

    for p in png_paths:
        # Start a new page every 10 successfully placed images
        if placed > 0 and (placed % per_page) == 0:
            pages.append(page)
            page = _new_page()

        try:
            img = Image.open(p).convert("RGB")
        except Exception as e:
            print(f"[WARN] Failed to open {p.name}: {e}")
            continue

        # Compute slot position on current page
        idx = placed % per_page
        r = idx // cols
        c = idx % cols

        # Fit image into slot (preserve aspect ratio), then apply padding scale
        w, h = img.size
        base_scale = min(slot_w / float(w), slot_h / float(h))
        scale = base_scale * image_scale
        new_w = max(1, int(w * scale))
        new_h = max(1, int(h * scale))
        img = img.resize((new_w, new_h), Image.LANCZOS)

        # Center within slot
        x0 = margin_side + c * (slot_w + inner_margin)
        y0 = margin_top + r * (slot_h + inner_margin)
        x = x0 + (slot_w - new_w) // 2
        y = y0 + (slot_h - new_h) // 2

        page.paste(img, (x, y))
        placed += 1

    pages.append(page)

    first, *rest = pages
    first.save(out_path, save_all=True, append_images=rest, resolution=PDF_RESOLUTION)
    print(f"[grid-pdf] Saved high-res 2x5 PDF: {out_path.name}")



# ---------------------------------------------------------------------------
#  2-bar slicing & saving (no grouping)
# ---------------------------------------------------------------------------

def slice_and_save_2bars(
    infile: Path,
    start_idx: int,
    forced_genre: Optional[str],
    export_grid: bool,
    grid_pdf: bool,
    no_overwrite: bool,
    names_file: Optional[Path] = None,
) -> None:
    mf = mido.MidiFile(infile)
    if mf.type not in (0, 1):
        raise SystemExit("Only Type 0 or 1 is supported.")

    # pick source track
    if mf.type == 0:
        src_track = mf.tracks[0]
    else:
        src_track = mido.merge_tracks(mf.tracks)

    abs_msgs = build_absolute_track(src_track)
    if not abs_msgs:
        print("No messages in file; nothing to do.")
        return

    tpq = mf.ticks_per_beat
    num0, den0 = current_time_signature(src_track, 0, tpq)
    bar_ticks = ticks_per_bar(tpq, num0, den0)

    total_ticks = abs_msgs[-1].time
    total_bars = total_ticks // bar_ticks

    if total_bars < 2:
        print("Not enough bars for 2-bar slicing.")
        return

    # genre code
    if forced_genre:
        genre = sanitize_83(forced_genre)[:3]
        print(f"Genre forced: {genre}")
    else:
        genre = infer_genre_code_from_name(infile.name)
        print(f"Genre inferred from filename: {genre}")

    out_dir = infile.parent

    # Optional naming override CSV file
    names_map: dict[int, str] = {}
    if names_file is not None:
        if not names_file.exists():
            raise SystemExit(f"--names file not found: {names_file}")
        names_map = load_names_file_csv(names_file)
        print(f"[names] Loaded {len(names_map)} name mapping(s) from {names_file.name}")

    # --- effective_start_idx for --no-overwrite ---
    effective_start_idx = start_idx
    if no_overwrite:
        prefix = genre[:3].upper()
        max_num = 0
        for path in out_dir.glob('*.MID'):
            m = re.match(r'^([A-Z0-9_]{3})_P(\d{3})\.MID$', path.name, re.IGNORECASE)
            if not m:
                continue
            code3 = m.group(1).upper()
            if code3 != prefix:
                continue
            num = int(m.group(2))
            if num > max_num:
                max_num = num
        if max_num > 0:
            candidate = max_num + 1
            if candidate < start_idx:
                candidate = start_idx
            effective_start_idx = candidate
            print(f"[no-overwrite] Existing {prefix}_P*** up to {max_num:03d}, "
                  f"starting from {effective_start_idx:03d}")
        else:
            effective_start_idx = start_idx

    # --- Base 2-bar slices (start on even-numbered bars) ---
    slice_starts: List[Tuple[int, int]] = []
    b = 0
    while b + 1 < total_bars:
        start_tick = b * bar_ticks
        end_tick = start_tick + 2 * bar_ticks
        if end_tick <= total_ticks:
            slice_starts.append((start_tick, b))
        b += 2

    used_bars = len(slice_starts) * 2
    dropped_full_bars = max(0, total_bars - used_bars)

    # --- Tail remainder calculation ---
    tail_start_tick = total_bars * bar_ticks
    tail_ticks = total_ticks - tail_start_tick

    print(f"\n=== 2-bar slicing report for {infile.name} ===")
    print(f"Ticks per beat      : {tpq}")
    print(f"Initial time sig    : {num0}/{den0}")
    print(f"Bar ticks           : {bar_ticks}")
    print(f"Total ticks         : {total_ticks}")
    print(f"Total bars (floor)  : {total_bars}")
    print(f"Used bars (2-bar xN): {used_bars}")
    print(f"Dropped full bars   : {dropped_full_bars}")
    print(f"Tail remainder      : {tail_ticks} ticks beyond full bars\n")

    if dropped_full_bars > 0:
        print(f"- Note: The last {dropped_full_bars} full bar(s) were not used.")

    # --- If tail >= 0.5 bar, add one extra final 2-bar slice ---
    # (Avoid duplication if a slice with the same start tick already exists.)
    if tail_ticks >= bar_ticks // 2:
        extra_start_bar = max(total_bars - 1, 0)     # 마지막 바로부터 2마디
        extra_start_tick = extra_start_bar * bar_ticks
        if not any(st == extra_start_tick for st, _ in slice_starts):
            slice_starts.append((extra_start_tick, extra_start_bar))
            print(f"[INFO] Tail >= 0.5 bar → extra 2-bar slice from bar {extra_start_bar+1}")
    elif tail_ticks > 0:
        print(f"- Note: Tail < 0.5 bar → ignored (no extra slice).")

    if not slice_starts:
        print("No 2-bar slices produced.")
        return

    # --- create one MIDI file per slice ---
    current_idx = effective_start_idx
    grid_png_paths: List[Path] = []

    for slice_idx, (start_tick, start_bar) in enumerate(sorted(slice_starts, key=lambda x: x[0])):
        end_tick = start_tick + 2 * bar_ticks
        length = end_tick - start_tick

        # collect events inside window (CH10 only)
        window_msgs: List[mido.Message] = []
        tempos_inside: List[Tuple[int, int]] = []

        for m in abs_msgs:
            if start_tick <= m.time < end_tick:
                rel = m.time - start_tick
                if m.type in ('note_on', 'note_off') and getattr(m, 'channel', None) == 9:
                    if m.type == 'note_on' and m.velocity > 0:
                        window_msgs.append(
                            mido.Message('note_on', note=m.note, velocity=m.velocity, channel=9, time=rel)
                        )
                    else:
                        window_msgs.append(
                            mido.Message('note_off', note=m.note, velocity=0, channel=9, time=rel)
                        )
                elif m.type == 'set_tempo':
                    tempos_inside.append((rel, m.tempo))

        # skip empty slices
        has_notes = any(
            (m.type == 'note_on' and m.velocity > 0) for m in window_msgs
        )
        if not has_notes:
            continue

        # build new MidiFile
        out = mido.MidiFile(type=1, ticks_per_beat=tpq)
        tr = mido.MidiTrack()
        out.tracks.append(tr)

        num, den = current_time_signature(src_track, start_tick, tpq)
        tr.append(mido.MetaMessage('time_signature', numerator=num, denominator=den, time=0))
        tempo0 = current_tempo(src_track, start_tick)
        tr.append(mido.MetaMessage('set_tempo', tempo=tempo0, time=0))

        for rel, tval in tempos_inside:
            tr.append(mido.MetaMessage('set_tempo', tempo=tval, time=0))  # time=0, rough but ok

        # sort window messages by time, meta first (already abs rel)
        window_msgs.sort(key=lambda x: (x.time, 0 if x.is_meta else 1))

        last_rel = 0
        for m in window_msgs:
            dt = m.time - last_rel
            last_rel = m.time
            m.time = dt
            tr.append(m)

        tr.append(mido.MetaMessage('end_of_track', time=0))

        # output file name
        pat_idx = current_idx
        default_basename = f"{genre[:3]}_P{pat_idx:03d}"
        basename = choose_basename_csv(default_basename=default_basename, pat_idx=pat_idx, names_map=names_map)
        out_path = out_dir / f"{basename}.MID"
        out.save(out_path)
        print(f"Saved slice {slice_idx} (bars {start_bar+1}-{start_bar+2}) -> {out_path.name}")

        # optional grid export
        if export_grid:
            events_by_tick = build_events_by_tick(abs_msgs, start_tick, end_tick, channel=9)

            # Grid detection (straight / triplet-8T / triplet-16T)
            steps_per_bar, grid_label = detect_steps_per_bar_for_pattern(events_by_tick, bar_ticks)
            cols = steps_per_bar * 2  # 2-bar 기준 칸 수

            print(
                f"[grid] {basename}: detected grid = {grid_label} "
                f"({steps_per_bar} steps/bar, {cols} cols for 2 bars)"
            )

            pat_for_grid = PatternForGrid(length=length, events_by_tick=events_by_tick)
            png_path = out_dir / f"{basename}_grid.png"
            title = f"{basename} (bars {start_bar+1}-{start_bar+2}, {grid_label})"
            export_pattern_grid_png(pat_for_grid, title, png_path, cols=cols)
            grid_png_paths.append(png_path)

        current_idx += 1

    # Collect PNGs into a multi-page PDF (optional) + Ghostscript A4 resize
    if export_grid and grid_pdf and grid_png_paths:
        # Build PDF filename from input MIDI stem
        stem = infile.stem
        safe_stem = re.sub(r'[^A-Za-z0-9_\-]+', '_', stem)

        # First create a temporary large-page (high-res) PDF
        raw_pdf_name = f"{safe_stem}_grids_A4_2col_big.pdf"
        raw_pdf_path = out_dir / raw_pdf_name

        final_pdf_name = f"{safe_stem}_grids_A4_2col.pdf"
        final_pdf_path = out_dir / final_pdf_name

        export_grid_pdf_two_column(grid_png_paths, raw_pdf_path, infile.name)

        # Locate Ghostscript
        gs_exe = find_ghostscript_executable()
        if not gs_exe:
            print("[grid-pdf] Ghostscript not found in PATH.")
            print(f"           Keeping original large-page PDF: {raw_pdf_path.name}")
            # Attempt rename to the expected final filename for convenience
            try:
                if not final_pdf_path.exists():
                    raw_pdf_path.rename(final_pdf_path)
                    print(f"[grid-pdf] Renamed to: {final_pdf_path.name}")
            except OSError as e:
                print(f"[grid-pdf] Rename failed: {e}")
            return

        # Perform A4 resize via Ghostscript
        if convert_pdf_to_a4_with_ghostscript(gs_exe, raw_pdf_path, final_pdf_path):
            print(f"[grid-pdf] Saved resized A4 PDF: {final_pdf_path.name}")
            # Remove temporary large-page PDF
            try:
                raw_pdf_path.unlink()
            except OSError:
                pass
        
            # Remove source grid PNG files after successful PDF creation
            for p in grid_png_paths:
                try:
                    p.unlink()
                except OSError as e:
                    print(f"[grid-pdf] WARNING: failed to remove {p.name}: {e}")
        
        else:
            print("[grid-pdf] Ghostscript conversion failed.")
            print(f"           Keeping original large-page PDF: {raw_pdf_path.name}")
            try:
                if not final_pdf_path.exists():
                    raw_pdf_path.rename(final_pdf_path)
                    print(f"[grid-pdf] Renamed to: {final_pdf_path.name}")
            except OSError as e:
                print(f"[grid-pdf] Rename failed: {e}")


# ---------------------------------------------------------------------------
#  CLI
# ---------------------------------------------------------------------------

def main():
    ap = argparse.ArgumentParser(description="Slice CH10 (drums) into 2-bar pattern MIDI files, with optional grid PNG/PDF export.")
    ap.add_argument('input', help='Input MIDI file (Type 0 or 1).')
    ap.add_argument('--start', type=int, default=1,
                    help='Starting index (default: 1 => 001).')
    ap.add_argument('--genre', type=str, default=None,
                    help='Force 3-letter genre code (e.g., RCK).')
    ap.add_argument('--names', type=str, default=None,
                    help='Optional CSV naming override file with columns index,name. '
                         'Index corresponds to output PNNN. Additional columns are ignored.')
    ap.add_argument('--export-grid', action='store_true',
                    help='Export 2-bar drum grids as PNG for each slice.')
    ap.add_argument('--grid-pdf', action='store_true',
                    help=('Collect exported grid PNGs into a multi-page PDF '
                          '(two columns per page). If Ghostscript is in PATH, '
                          'resize to A4 page size automatically. '
                          'Source PNG files will be deleted. '))
    ap.add_argument('--no-overwrite', action='store_true',
                    help=('Do not overwrite existing <GEN>_Pnnn.MID; '
                          'auto-detect max existing number and start from the next '
                          'or --start, whichever is larger.'))
    ap.add_argument('--print-genre-only', action='store_true',
                    help=('Only infer genre code from the input filename/title '
                          'and print it, then exit.'))
    args = ap.parse_args()

    infile = Path(args.input)
    if not infile.exists():
        raise SystemExit(f"Input not found: {infile}")

    # Genre-only mode: do not touch MIDI contents; infer genre from filename and exit.
    if args.print_genre_only:
        if args.genre:
            genre = sanitize_83(args.genre)[:3]
            print(f"[GENRE] Forced by --genre : {genre}")
        else:
            genre = infer_genre_code_from_name(infile.name)
            print(f"[GENRE] Inferred from filename '{infile.name}' : {genre}")
        return

    slice_and_save_2bars(
        infile,
        start_idx=args.start,
        forced_genre=args.genre,
        export_grid=args.export_grid,
        grid_pdf=args.grid_pdf,
        no_overwrite=args.no_overwrite,
        names_file=(Path(args.names) if args.names else None),
    )


if __name__ == '__main__':
    main()
